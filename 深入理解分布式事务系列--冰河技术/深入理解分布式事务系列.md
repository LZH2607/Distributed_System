# 深入理解分布式事务系列

主讲：冰河
[合集·深入理解分布式事务系列](https://space.bilibili.com/517638832/channel/collectiondetail?sid=415480)



[toc]



## 第1讲 为何学习分布式事务

互联网发展背景：单体应用架构 → 垂直应用架构 → 分布式架构 → SOA架构 → 微服务架构

数据一致性问题

分布式事务理论与模型：
CAP理论、BASE理论
强一致性分布式事务模型：DTP、2PC、3PC、XA
最终一致性分布式事务模型（高并发、大流量场景）：TCC、可靠消息最终一致性、最大努力通知



## 第2讲 事务的特性与类型

事务的特性：ACID
	原子性（A：Atomicity）：要么全部执行、要么全部不执行（例子：转账）
	一致性（C：Consistency）：在事务执行之前和执行之后，数据处于一致的状态
	隔离性（I：Isolation）：事务之间互不干扰、一个事务在执行过程中，不能看到其他事务执行过程的中间状态
	持久性（D：Durability）：事务提交完成后，对数据的更改操作会被持久化到数据库中，不会被回滚

事务的类型：
	扁平事务：数据库中的begin / start transaction、commit、rollback
	带有保存点的扁平事务
	链式事务：（没懂）
	嵌套事务：顶层事务、内部子事务
	分布式事务：不同服务、不同数据库（例子：电商系统）



## 第3讲 本地事务

本地事务 / 传统事务：基于关系型数据库的事务（通过关系型数据库对事务进行控制），数据库和应用通常在同一台服务器中

特点：
	只能连接一个事务性数据库，使用数据库本身的锁
	满足ACID

优点：
	支持严格ACID
	事务可靠
	执行效率高
	事务状态可以只在数据库中维护：上层应用不必理会事务状态
	编程模型简单

缺点：
	不具备分布式事务的处理能力
	不能用于多个事务性数据库



## 第4讲 并发事务带来的问题

补充：[阿里一面：什么是脏读、幻读、不可重复读 ？你分别说一下？](https://www.bilibili.com/video/BV19M411Z76o)

并发事务带来的问题：
	更新丢失 / 脏写
	脏读
	不可重复读
	幻读

更新丢失 / 脏写：一个事务对数据的更新操作覆盖了别的事务对该数据的更新操作
	本质：写操作冲突
	解决：让事务串行执行

脏读：一个事务读取了另一个事务未提交的数据
	本质：读写操作冲突
	解决：先写后读

不可重复读：一个事务在不同时刻读取的数据不同（另一个事务更新了该数据，已提交）
	本质：读写操作冲突
	解决：先读后写

幻读：一个事务在不同时刻读取一个范围的数据不同（另一个事务新增了数据，已提交）
	本质：读写操作冲突
	解决：先读后写

不可重复读 vs 幻读：
	不可重复读：更新、删除
	幻读：插入

使用锁机制实现事务隔离级别：第一次读取数据时加锁 → 可重复读
	无法对新插入的数据加锁 → 幻读

幻读无法通过行级锁避免
	解决：使用串行化的事务隔离级别（缺点：降低数据库的并发能力，故一般不使用）

解决不可重复读、幻读：
	悲观锁
	乐观锁：MySQL使用MVCC机制（多版本并发控制机制）



## 第5讲 MySQL事务隔离级别

MySQL事务隔离级别：
	读未提交（Read Uncommitted）
	读已提交（Read Committed）：Oracle数据库默认使用
	可重复读（Repeatable Read）：MySQL InnoDB存储引擎默认使用
	串行化（Serializable）：数据库失去并发特性，故不常用

| 事务隔离级别 |  脏读  | 不可重复读 |  幻读  |
| :----------: | :----: | :--------: | :----: |
|   读未提交   |  可能  |    可能    |  可能  |
|   读已提交   | 不可能 |    可能    |  可能  |
|   可重复读   | 不可能 |   不可能   |  可能  |
|    串行化    | 不可能 |   不可能   | 不可能 |

设置事务隔离级别：
	命令行 / 更改配置文件：略
	SQL命令：set transaction（参数略）

查询事务隔离级别：略（SQL命令：select）



## 第6讲 MySQL中各种类型的锁

MySQL中的锁的分类：
	按性能分：悲观锁、乐观锁
	按操作类型分：读锁、写锁
	按数据粒度分：表锁、行锁、页面锁
	按更细粒度分：间隙锁、临键锁

悲观锁：在整个数据处理的过程中锁定数据（读取时加锁：数据不能修改、修改时加锁：数据不能读取）
	在数据库中实现悲观锁依赖于数据库提供的锁机制
	降低数据库的性能

乐观锁：在整个数据处理的过程中，通过数据版本对比实现
	为数据增加一个版本标识
	更新数据：版本+1
	提交数据：提交版本>表中版本时才修改

读锁 / 共享锁 / S锁（Shared锁）：同一个数据可以加多个读锁（读锁未释放前不能增加写锁）

写锁 / 独享锁 / 排他锁 / X锁（Exclusive锁）：写锁未释放前会阻塞其他读锁和写锁

表锁：在整个数据表上加锁、释放锁
	表共享锁、表独占写锁
	SQL命令：lock table 略（添加表锁）、unlock table（释放表锁）

行锁：在数据行上加锁、释放锁
	InnoDB存储引擎的两种类型的行锁：共享锁（S）、排他锁（X）
	注意点：对索引加锁，不对记录加锁，否则行锁可能会变成表锁
	SQL命令：略

页面锁：在页面级别对数据加锁、释放锁

表锁 vs 页面锁 vs 行锁：

|   锁   | 锁定粒度 | 系统开销 | 加锁速度 | 出现死锁 | 发生锁冲突 | 并发度 |
| :----: | :------: | :------: | :------: | :------: | :--------: | :----: |
|  表锁  |   最大   |   最小   |   最快   | 一般不会 |  概率最大  |  最低  |
| 页面锁 |   中等   |   中等   |   中等   |  可能会  |  概率中等  |  中等  |
|  行锁  |   最小   |   最大   |   最慢   |  可能会  |  概率最小  |  最高  |

间隙锁（Gap Lock）：（范围操作）对两个值之间的空隙加锁
	MySQL默认隔离级别为可重复读（存在幻读问题），间隙锁可以一定程度地解决幻读问题	

临键锁（Next-key Lock）：行锁与间隙锁的组合



## 第7讲 死锁问题

